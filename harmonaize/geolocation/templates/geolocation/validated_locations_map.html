<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validated Locations Map - GeoValidator</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        .mapboxgl-popup-content {
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        
        .validated-marker {
            border-radius: 50%;
            border: 3px solid #ffffff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .validated-marker:hover {
            transform: scale(1.2);
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .download-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .loading-spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid #10b981;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .map-layer-control {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .layer-button {
            transition: all 0.3s ease;
            border-radius: 8px;
        }

        .layer-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .layer-button.active {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .legend-item {
            display: flex;
            align-items: center;
            padding: 4px 0;
            font-size: 12px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 2px solid #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        #downloadCanvas {
            position: absolute;
            top: -9999px;
            left: -9999px;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-green-50 to-blue-50 h-screen overflow-hidden">
    <div class="h-screen flex flex-col">
        <!-- Enhanced Header -->
        <header class="bg-white shadow-lg border-b-2 border-green-100 h-16 flex-shrink-0">
            <div class="h-full px-6 flex justify-between items-center">
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2">
                        <div class="w-8 h-8 bg-gradient-to-br from-green-500 to-emerald-600 rounded-lg flex items-center justify-center">
                            <span class="text-white text-sm font-bold">‚úÖ</span>
                        </div>
                        <h1 class="text-xl font-bold bg-gradient-to-r from-green-600 to-emerald-600 bg-clip-text text-transparent">
                            Validated Locations Map
                        </h1>
                    </div>
                    
                    <div class="flex items-center space-x-2">
                        <span class="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm font-medium">
                            {{ total_locations }} Validated Locations
                        </span>
                    </div>
                </div>
                
                <div class="flex items-center space-x-3">
                    <a href="{% url 'geolocation:validation_dashboard' %}" 
                       class="bg-gray-100 hover:bg-gray-200 text-gray-700 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 hover:scale-105">
                        ‚Üê Back to Dashboard
                    </a>
                </div>
            </div>
        </header>

        <!-- Map Container -->
        <div class="flex-1 relative">
            <div id="map" class="w-full h-full"></div>
            
            <!-- Map Layer Control -->
            <div class="absolute top-4 left-4 map-layer-control p-4 text-sm">
                <h4 class="font-bold text-gray-900 mb-3">üó∫Ô∏è Map Layers</h4>
                <div class="grid grid-cols-1 gap-2">
                    <button onclick="changeMapLayer('satellite')" 
                            class="layer-button px-3 py-2 text-left text-gray-700 hover:bg-gray-100 active" 
                            id="satellite-btn">
                        üõ∞Ô∏è Satellite
                    </button>
                    <button onclick="changeMapLayer('streets')" 
                            class="layer-button px-3 py-2 text-left text-gray-700 hover:bg-gray-100" 
                            id="streets-btn">
                        üó∫Ô∏è Streets
                    </button>
                    <button onclick="changeMapLayer('terrain')" 
                            class="layer-button px-3 py-2 text-left text-gray-700 hover:bg-gray-100" 
                            id="terrain-btn">
                        üèîÔ∏è Terrain
                    </button>
                    <button onclick="changeMapLayer('outdoors')" 
                            class="layer-button px-3 py-2 text-left text-gray-700 hover:bg-gray-100" 
                            id="outdoors-btn">
                        üå≤ Outdoors
                    </button>
                </div>
            </div>

            <!-- Enhanced Download Panel -->
            <div class="absolute top-4 right-4 download-panel p-4 text-sm">
                <h4 class="font-bold text-gray-900 mb-3">üì• Download Map</h4>
                <div class="space-y-2">
                    <button onclick="downloadMap('pdf')" 
                            class="w-full bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center justify-center space-x-2">
                        <span>üìÑ</span>
                        <span>Download PDF</span>
                    </button>
                    <button onclick="downloadMap('png')" 
                            class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center justify-center space-x-2">
                        <span>üñºÔ∏è</span>
                        <span>Download PNG</span>
                    </button>

                </div>
                
                <!-- Download Progress -->
                <div id="downloadProgress" class="hidden mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                    <div class="flex items-center space-x-2">
                        <div class="loading-spinner"></div>
                        <span class="text-sm text-blue-800">Generating download...</span>
                    </div>
                </div>
            </div>

            <!-- Enhanced Legend Panel -->
            <div class="absolute bottom-4 left-4 bg-white/95 backdrop-blur-sm rounded-xl shadow-lg p-4 text-sm border border-gray-200 max-h-64 overflow-y-auto">
                <h4 class="font-bold text-gray-900 mb-3">üè∑Ô∏è Location Legend</h4>
                <div id="locationLegend" class="space-y-1">
                    <!-- Dynamic legend will be populated here -->
                </div>
                <div class="mt-3 pt-2 border-t border-gray-200 text-xs text-gray-500">
                    Total: {{ total_locations }} validated locations
                </div>
            </div>

            <!-- Statistics Panel -->
            <div class="absolute bottom-4 right-4 bg-white/90 backdrop-blur-sm rounded-xl shadow-lg p-4 text-sm border border-gray-200">
                <h4 class="font-bold text-gray-900 mb-2">üìä Map Info</h4>
                <div class="space-y-1 text-xs">
                    <div class="flex justify-between">
                        <span class="text-gray-600">Locations:</span>
                        <span class="font-bold text-green-600">{{ total_locations }}</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-600">Zoom Level:</span>
                        <span class="font-bold text-gray-900" id="currentZoom">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-600">Center:</span>
                        <span class="font-bold text-gray-900 text-xs" id="currentCenter">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden canvas for download generation -->
    <canvas id="downloadCanvas" width="1200" height="800"></canvas>

    <!-- Messages Container -->
    <div id="messageContainer" class="fixed top-20 left-1/2 transform -translate-x-1/2 z-50 space-y-2"></div>

    <script>
        // Initialize map
        mapboxgl.accessToken = '{{ mapbox_token }}';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/satellite-streets-v11',
            center: [25, -15],
            zoom: 5
        });

        const locationsData = {{ locations_data|safe }};
        let markers = [];
        let currentMapStyle = 'satellite';
        let locationColors = {};

        // Enhanced color palette for better distinction
        const colorPalette = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#e91e63', '#ff5722',
            '#607d8b', '#795548', '#009688', '#4caf50', '#8bc34a',
            '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722',
            '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4',
            '#00bcd4', '#004d40', '#1b5e20', '#bf360c', '#e65100'
        ];

        // Map layer styles
        const mapStyles = {
            'satellite': 'mapbox://styles/mapbox/satellite-streets-v11',
            'streets': 'mapbox://styles/mapbox/streets-v11',
            'terrain': 'mapbox://styles/mapbox/outdoors-v11',
            'outdoors': 'mapbox://styles/mapbox/outdoors-v11'
        };

        // Generate unique colors for each location
        function assignLocationColors() {
            locationsData.forEach((location, index) => {
                locationColors[location.name] = colorPalette[index % colorPalette.length];
            });
        }

        // Create enhanced legend
        function createLocationLegend() {
            const legendContainer = document.getElementById('locationLegend');
            legendContainer.innerHTML = '';
            
            locationsData.forEach((location) => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${locationColors[location.name]}"></div>
                    <span class="truncate">${location.name}</span>
                `;
                legendContainer.appendChild(legendItem);
            });
        }

        // Map layer switching
        function changeMapLayer(layerType) {
            if (layerType === currentMapStyle) return;
            
            document.querySelectorAll('.layer-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${layerType}-btn`).classList.add('active');
            
            map.setStyle(mapStyles[layerType]);
            currentMapStyle = layerType;
            
            map.on('styledata', function() {
                setTimeout(() => {
                    addMarkersToMap();
                }, 100);
            });
        }

        // Add markers to map with unique colors
        function addMarkersToMap() {
            markers.forEach(marker => marker.remove());
            markers = [];

            if (locationsData.length === 0) {
                showMessage('No validated locations found', 'info');
                return;
            }

            const bounds = new mapboxgl.LngLatBounds();

            locationsData.forEach((location, index) => {
                const el = document.createElement('div');
                el.className = 'validated-marker';
                el.style.width = '16px';
                el.style.height = '16px';
                el.style.backgroundColor = locationColors[location.name];

                const popupHTML = `
                    <div class="text-sm">
                        <div class="font-bold text-lg mb-2" style="color: ${locationColors[location.name]}">${location.name}</div>
                        <div class="space-y-2 mb-3">
                            <div class="bg-green-50 rounded p-2">
                                <div class="text-xs text-green-600 font-medium">‚úÖ Validated Coordinates</div>
                                <div class="font-mono text-sm text-gray-800">${location.lat.toFixed(5)}, ${location.lng.toFixed(5)}</div>
                            </div>
                            <div class="bg-gray-50 rounded p-2">
                                <div class="text-xs text-gray-500">Status</div>
                                <div class="text-sm font-medium text-green-600">Ready for Analysis</div>
                            </div>
                        </div>
                        <button onclick="zoomToLocation(${location.lat}, ${location.lng})" 
                                class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg text-sm w-full font-medium transition-all duration-200">
                            üîç Zoom to Location
                        </button>
                    </div>
                `;

                const popup = new mapboxgl.Popup({ 
                    offset: 15,
                    closeButton: true,
                    closeOnClick: false
                }).setHTML(popupHTML);
                
                const marker = new mapboxgl.Marker(el)
                    .setLngLat([location.lng, location.lat])
                    .setPopup(popup)
                    .addTo(map);
                
                markers.push(marker);
                bounds.extend([location.lng, location.lat]);
            });

            if (locationsData.length > 1) {
                map.fitBounds(bounds, { 
                    padding: 60,
                    maxZoom: 16
                });
            } else if (locationsData.length === 1) {
                map.flyTo({
                    center: [locationsData[0].lng, locationsData[0].lat],
                    zoom: 14,
                    duration: 1500
                });
            }
        }

        function zoomToLocation(lat, lng) {
            map.flyTo({
                center: [lng, lat],
                zoom: 16,
                duration: 1500,
                essential: true
            });
        }

        // ENHANCED DOWNLOAD FUNCTIONALITY - PDF and PNG only
        function downloadMap(format) {
            const downloadProgress = document.getElementById('downloadProgress');
            downloadProgress.classList.remove('hidden');
            
            showMessage('üîÑ Creating enhanced map with basemap...', 'info');
            
            if (format === 'pdf') {
                generateEnhancedPDF();
            } else if (format === 'png') {
                generateEnhancedPNG();
            }
        }

        // Generate PDF with proper basemap and FIXED positioning/centering
        function generateEnhancedPDF() {
            const canvas = document.getElementById('downloadCanvas');
            const ctx = canvas.getContext('2d');
            // Increased height for better spacing
            canvas.width = 1200;
            canvas.height = 900;
            
            // Clear canvas
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calculate map bounds with proper padding
            const bounds = getLocationBounds();
            const zoom = calculateOptimalZoom(bounds, 700, 400);
            
            // FIXED: Centered map area with proper margins
            const mapArea = { 
                x: (canvas.width - 800) / 2,  // Center horizontally
                y: 100, 
                width: 800, 
                height: 450 
            };
            
            // Get multiple tiles to cover the area
            const tilesNeeded = calculateTileCoverage(bounds, zoom, mapArea.width, mapArea.height);
            let tilesLoaded = 0;
            let totalTiles = tilesNeeded.tiles.length;
            
            if (totalTiles === 0) {
                generateFallbackPDF();
                return;
            }
            
            // Load all necessary tiles
            const tileImages = [];
            
            tilesNeeded.tiles.forEach((tile, index) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = function() {
                    tileImages[index] = { img: img, tile: tile };
                    tilesLoaded++;
                    
                    if (tilesLoaded === totalTiles) {
                        // All tiles loaded, now draw the map
                        drawPDFWithTiles(canvas, ctx, tileImages, tilesNeeded, bounds, mapArea);
                    }
                };
                
                img.onerror = function() {
                    tilesLoaded++;
                    if (tilesLoaded === totalTiles) {
                        // Some tiles failed, draw what we have
                        drawPDFWithTiles(canvas, ctx, tileImages, tilesNeeded, bounds, mapArea);
                    }
                };
                
                img.src = `https://tile.openstreetmap.org/${zoom}/${tile.x}/${tile.y}.png`;
            });
        }
        
        function drawPDFWithTiles(canvas, ctx, tileImages, tilesNeeded, bounds, mapArea) {
            // Clear canvas completely
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fresh background
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw title
            ctx.fillStyle = '#059669';
            ctx.font = 'bold 28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Validated Locations Map', canvas.width / 2, 40);
            
            ctx.fillStyle = '#6b7280';
            ctx.font = '16px Arial';
            ctx.fillText(`HarmonAIze Geolocation Platform | ${locationsData.length} Locations`, canvas.width / 2, 70);
            
            // Draw map background
            ctx.fillStyle = '#e0f2fe';
            ctx.fillRect(mapArea.x, mapArea.y, mapArea.width, mapArea.height);
            ctx.strokeStyle = '#0369a1';
            ctx.lineWidth = 2;
            ctx.strokeRect(mapArea.x, mapArea.y, mapArea.width, mapArea.height);
            
            // Draw tiles without duplication
            const drawnTiles = new Set();
            tileImages.forEach((tileData) => {
                if (tileData && tileData.img) {
                    const tile = tileData.tile;
                    const tileKey = `${tile.x}-${tile.y}`;
                    
                    if (!drawnTiles.has(tileKey)) {
                        drawnTiles.add(tileKey);
                        const tilePixelX = mapArea.x + (tile.x - tilesNeeded.minTileX) * 256;
                        const tilePixelY = mapArea.y + (tile.y - tilesNeeded.minTileY) * 256;
                        
                        if (tilePixelX < mapArea.x + mapArea.width && tilePixelY < mapArea.y + mapArea.height) {
                            ctx.drawImage(tileData.img, tilePixelX, tilePixelY, 256, 256);
                        }
                    }
                }
            });
            
            // Plot locations with correct coordinate transformation
            locationsData.forEach((location) => {
                const tileCoords = getTileCoords(location.lat, location.lng, tilesNeeded.zoom);
                const pixelX = (tileCoords.x - tilesNeeded.minTileX) * 256 + tileCoords.pixelX;
                const pixelY = (tileCoords.y - tilesNeeded.minTileY) * 256 + tileCoords.pixelY;
                
                const mapX = mapArea.x + pixelX;
                const mapY = mapArea.y + pixelY;
                
                // Only draw if within map area
                if (mapX >= mapArea.x && mapX <= mapArea.x + mapArea.width && 
                    mapY >= mapArea.y && mapY <= mapArea.y + mapArea.height) {
                    
                    // Draw marker
                    ctx.fillStyle = locationColors[location.name];
                    ctx.beginPath();
                    ctx.arc(mapX, mapY, 10, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // White border
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Add location label
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(location.name, mapX, mapY + 25);
                }
            });
            
            // FIXED: Position legend below map to avoid covering locations
            const legendY = 620; // Below the map area
            addLegendToPDF(ctx, 50, legendY, canvas.width - 100, 120);
            
            // Add metadata
            ctx.fillStyle = '#6b7280';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Generated: ${new Date().toLocaleDateString()} | Zoom: ${tilesNeeded.zoom} | Source: HarmonAIze Platform`, 50, canvas.height - 10);
            
            // Convert to PDF
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('l', 'mm', 'a4');
            const imgData = canvas.toDataURL('image/png');
            pdf.addImage(imgData, 'PNG', 10, 10, 277, 190);
            pdf.save(`validated-locations-map-${new Date().toISOString().split('T')[0]}.pdf`);
            
            document.getElementById('downloadProgress').classList.add('hidden');
            showMessage('‚úÖ Enhanced PDF with accurate positioning downloaded!', 'success');
        }
        
        // Separate legend function for PDF to avoid map overlap
        function addLegendToPDF(ctx, x, y, width, height) {
            // Legend background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(x, y, width, height);
            ctx.strokeStyle = '#d1d5db';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            
            // Legend title
            ctx.fillStyle = '#374151';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Location Legend', x + 15, y + 25);
            
            // Legend items in horizontal layout to save space
            const itemWidth = (width - 30) / locationsData.length;
            
            locationsData.forEach((location, index) => {
                const itemX = x + 15 + (index * itemWidth);
                const itemY = y + 45;
                
                // Color dot
                ctx.fillStyle = locationColors[location.name];
                ctx.beginPath();
                ctx.arc(itemX + 8, itemY, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Location name
                ctx.fillStyle = '#374151';
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                
                // Truncate long names to fit
                let displayName = location.name;
                if (displayName.length > 12) {
                    displayName = displayName.substring(0, 10) + '...';
                }
                
                ctx.fillText(displayName, itemX + 18, itemY + 4);
                
                // Coordinates
                ctx.fillStyle = '#6b7280';
                ctx.font = '9px Arial';
                const coords = `${location.lat.toFixed(2)}, ${location.lng.toFixed(2)}`;
                ctx.fillText(coords, itemX + 18, itemY + 16);
            });
        }

        // Generate PNG with FIXED positioning, centering, and spacing
        function generateEnhancedPNG() {
            const canvas = document.getElementById('downloadCanvas');
            const ctx = canvas.getContext('2d');
            // Increased height to accommodate legend without overlap
            canvas.width = 1400;
            canvas.height = 1200;
            
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const bounds = getLocationBounds();
            const zoom = calculateOptimalZoom(bounds, 800, 500);
            
            // FIXED: Centered map area with proper margins
            const mapArea = { 
                x: (canvas.width - 1000) / 2,  // Center horizontally
                y: 120, 
                width: 1000, 
                height: 600 
            };
            
            // Get tile coverage
            const tilesNeeded = calculateTileCoverage(bounds, zoom, mapArea.width, mapArea.height);
            let tilesLoaded = 0;
            let totalTiles = tilesNeeded.tiles.length;
            
            if (totalTiles === 0) {
                generateFallbackPNG();
                return;
            }
            
            const tileImages = [];
            
            tilesNeeded.tiles.forEach((tile, index) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = function() {
                    tileImages[index] = { img: img, tile: tile };
                    tilesLoaded++;
                    
                    if (tilesLoaded === totalTiles) {
                        drawPNGWithTiles(canvas, ctx, tileImages, tilesNeeded, bounds, mapArea);
                    }
                };
                
                img.onerror = function() {
                    tilesLoaded++;
                    if (tilesLoaded === totalTiles) {
                        drawPNGWithTiles(canvas, ctx, tileImages, tilesNeeded, bounds, mapArea);
                    }
                };
                
                img.src = `https://tile.openstreetmap.org/${zoom}/${tile.x}/${tile.y}.png`;
            });
        }
        
        function drawPNGWithTiles(canvas, ctx, tileImages, tilesNeeded, bounds, mapArea) {
            // Clear canvas completely to avoid duplication
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Fresh background
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title
            ctx.fillStyle = '#059669';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Validated Locations Map', canvas.width / 2, 50);
            
            ctx.fillStyle = '#6b7280';
            ctx.font = '18px Arial';
            ctx.fillText(`${locationsData.length} Validated Locations | Generated: ${new Date().toLocaleDateString()}`, canvas.width / 2, 80);
            
            // Draw map container with border
            ctx.fillStyle = '#e0f2fe';
            ctx.fillRect(mapArea.x, mapArea.y, mapArea.width, mapArea.height);
            ctx.strokeStyle = '#0369a1';
            ctx.lineWidth = 2;
            ctx.strokeRect(mapArea.x, mapArea.y, mapArea.width, mapArea.height);
            
            // FIXED: Calculate proper tile positioning to center the map content
            const boundsWidth = bounds.east - bounds.west;
            const boundsHeight = bounds.north - bounds.south;
            const mapCenterLng = (bounds.east + bounds.west) / 2;
            const mapCenterLat = (bounds.north + bounds.south) / 2;
            
            // Calculate offset to center the map content within the map area
            const centerTileCoords = getTileCoords(mapCenterLat, mapCenterLng, tilesNeeded.zoom);
            const centerPixelX = (centerTileCoords.x - tilesNeeded.minTileX) * 256 + centerTileCoords.pixelX;
            const centerPixelY = (centerTileCoords.y - tilesNeeded.minTileY) * 256 + centerTileCoords.pixelY;
            
            const offsetX = mapArea.x + (mapArea.width / 2) - centerPixelX;
            const offsetY = mapArea.y + (mapArea.height / 2) - centerPixelY;
            
            // Draw tiles with proper centering
            const drawnTiles = new Set();
            tileImages.forEach((tileData) => {
                if (tileData && tileData.img) {
                    const tile = tileData.tile;
                    const tileKey = `${tile.x}-${tile.y}`;
                    
                    if (!drawnTiles.has(tileKey)) {
                        drawnTiles.add(tileKey);
                        const tilePixelX = offsetX + (tile.x - tilesNeeded.minTileX) * 256;
                        const tilePixelY = offsetY + (tile.y - tilesNeeded.minTileY) * 256;
                        
                        // Only draw if tile intersects with map area
                        if (tilePixelX < mapArea.x + mapArea.width && tilePixelY < mapArea.y + mapArea.height &&
                            tilePixelX + 256 > mapArea.x && tilePixelY + 256 > mapArea.y) {
                            
                            // Clip to map area
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(mapArea.x, mapArea.y, mapArea.width, mapArea.height);
                            ctx.clip();
                            
                            ctx.drawImage(tileData.img, tilePixelX, tilePixelY, 256, 256);
                            ctx.restore();
                        }
                    }
                }
            });
            
            // Plot locations with FIXED centering and NO LABELS
            locationsData.forEach((location) => {
                const tileCoords = getTileCoords(location.lat, location.lng, tilesNeeded.zoom);
                const pixelX = offsetX + (tileCoords.x - tilesNeeded.minTileX) * 256 + tileCoords.pixelX;
                const pixelY = offsetY + (tileCoords.y - tilesNeeded.minTileY) * 256 + tileCoords.pixelY;
                
                // Only draw if within map area
                if (pixelX >= mapArea.x && pixelX <= mapArea.x + mapArea.width && 
                    pixelY >= mapArea.y && pixelY <= mapArea.y + mapArea.height) {
                    
                    // Draw marker without label
                    ctx.fillStyle = locationColors[location.name];
                    ctx.beginPath();
                    ctx.arc(pixelX, pixelY, 12, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // NO LABELS - removed as requested
                }
            });
            
            // FIXED: Legend positioned well below map to avoid overlap
            const legendY = mapArea.y + mapArea.height + 50; // 50px below map
            addLegendToCanvas(ctx, 50, legendY, canvas.width - 100, 120);
            
            // Download
            const link = document.createElement('a');
            link.download = `validated-locations-map-${new Date().toISOString().split('T')[0]}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            document.getElementById('downloadProgress').classList.add('hidden');
            showMessage('‚úÖ Enhanced PNG with proper centering and positioning downloaded!', 'success');
        }



        // Helper functions
        function getLocationBounds() {
            if (locationsData.length === 0) return { north: 0, south: 0, east: 0, west: 0 };
            
            const lats = locationsData.map(l => l.lat);
            const lngs = locationsData.map(l => l.lng);
            
            const bounds = {
                north: Math.max(...lats),
                south: Math.min(...lats),
                east: Math.max(...lngs),
                west: Math.min(...lngs)
            };
            
            // FIXED: Better padding calculation for proper centering
            const latSpan = bounds.north - bounds.south;
            const lngSpan = bounds.east - bounds.west;
            
            // Use minimum span to ensure reasonable padding even for close locations
            const minSpan = 0.1; // Minimum 0.1 degree span
            const actualLatSpan = Math.max(latSpan, minSpan);
            const actualLngSpan = Math.max(lngSpan, minSpan);
            
            // Add 30% padding on all sides for better presentation
            const latPadding = actualLatSpan * 0.3;
            const lngPadding = actualLngSpan * 0.3;
            
            return {
                north: bounds.north + latPadding,
                south: bounds.south - latPadding,
                east: bounds.east + lngPadding,
                west: bounds.west - lngPadding
            };
        }

        function calculateOptimalZoom(bounds, mapWidth, mapHeight) {
            // Calculate the span of coordinates
            const latDiff = bounds.north - bounds.south;
            const lngDiff = bounds.east - bounds.west;
            
            // Calculate zoom based on coordinate span and map size
            const latZoom = Math.floor(Math.log2(360 / latDiff * mapHeight / 256));
            const lngZoom = Math.floor(Math.log2(360 / lngDiff * mapWidth / 256));
            
            // Use the smaller zoom to ensure all locations fit
            let zoom = Math.min(latZoom, lngZoom);
            
            // Constrain zoom to reasonable levels
            zoom = Math.max(1, Math.min(zoom, 15));
            
            return zoom;
        }

        // ENHANCED Helper functions for accurate coordinate mapping
        function calculateTileCoverage(bounds, zoom, mapWidth, mapHeight) {
            // Calculate which tiles we need to cover the bounds
            const nwTile = getTileCoords(bounds.north, bounds.west, zoom);
            const seTile = getTileCoords(bounds.south, bounds.east, zoom);
            
            const minTileX = Math.min(nwTile.x, seTile.x);
            const maxTileX = Math.max(nwTile.x, seTile.x);
            const minTileY = Math.min(nwTile.y, seTile.y);
            const maxTileY = Math.max(nwTile.y, seTile.y);
            
            const tiles = [];
            for (let x = minTileX; x <= maxTileX; x++) {
                for (let y = minTileY; y <= maxTileY; y++) {
                    tiles.push({ x, y });
                }
            }
            
            return {
                tiles,
                minTileX,
                maxTileX,
                minTileY,
                maxTileY,
                zoom
            };
        }

        function getTileCoords(lat, lng, zoom) {
            const n = Math.pow(2, zoom);
            const x = Math.floor(n * ((lng + 180) / 360));
            const latRad = lat * Math.PI / 180;
            const y = Math.floor(n * (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2);
            
            // Calculate pixel position within the tile
            const pixelX = ((lng + 180) / 360 * n - x) * 256;
            const pixelY = ((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n - y) * 256;
            
            return { x, y, pixelX, pixelY };
        }

        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth's radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function addLegendToCanvas(ctx, x, y, width, height) {
            // Legend background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(x, y, width, height);
            ctx.strokeStyle = '#d1d5db';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, width, height);
            
            // Legend title
            ctx.fillStyle = '#374151';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Location Legend', x + 20, y + 30);
            
            // Legend items
            const legendCols = 3;
            const colWidth = (width - 40) / legendCols;
            let currentCol = 0;
            let currentY = y + 50;
            
            locationsData.forEach((location, index) => {
                if (index > 0 && index % Math.ceil(locationsData.length / legendCols) === 0) {
                    currentCol++;
                    currentY = y + 50;
                }
                
                const itemX = x + 20 + (currentCol * colWidth);
                
                // Color dot
                ctx.fillStyle = locationColors[location.name];
                ctx.beginPath();
                ctx.arc(itemX + 8, currentY + 5, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Location name
                ctx.fillStyle = '#374151';
                ctx.font = '14px Arial';
                ctx.fillText(location.name, itemX + 20, currentY + 9);
                
                currentY += 25;
            });
        }

        function generateFallbackPDF() {
            // FIXED: Fallback PDF with proper layout and no labels
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('l', 'mm', 'a4');
            
            // Title
            pdf.setFontSize(24);
            pdf.setTextColor(5, 150, 105);
            pdf.text('Validated Locations Map', 148, 25, { align: 'center' });
            
            pdf.setFontSize(14);
            pdf.setTextColor(75, 85, 99);
            pdf.text('HarmonAIze Geolocation Platform', 148, 35, { align: 'center' });
            
            // Add organized location list with coordinates
            let y = 60;
            pdf.setFontSize(16);
            pdf.setTextColor(0, 0, 0);
            pdf.text('Validated Locations:', 20, y);
            
            locationsData.forEach((location, index) => {
                y += 12;
                const color = hexToRgb(locationColors[location.name]);
                pdf.setFillColor(color.r, color.g, color.b);
                pdf.circle(25, y - 2, 2, 'F');
                
                pdf.setFontSize(12);
                pdf.text(`${index + 1}. ${location.name}`, 32, y);
                pdf.setFontSize(10);
                pdf.setTextColor(100, 100, 100);
                pdf.text(`Coordinates: ${location.lat.toFixed(5)}, ${location.lng.toFixed(5)}`, 32, y + 5);
                pdf.setTextColor(0, 0, 0);
                y += 5;
            });
            
            // Add footer
            pdf.setFontSize(10);
            pdf.setTextColor(100, 100, 100);
            pdf.text(`Generated: ${new Date().toLocaleDateString()} | Source: HarmonAIze Platform`, 20, 190);
            
            pdf.save(`validated-locations-map-${new Date().toISOString().split('T')[0]}.pdf`);
            
            document.getElementById('downloadProgress').classList.add('hidden');
            showMessage('‚úÖ Fallback PDF downloaded with location details!', 'success');
        }

        function generateFallbackPNG() {
            const canvas = document.getElementById('downloadCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1400;
            canvas.height = 1200;
            
            ctx.fillStyle = '#f0f9ff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Title
            ctx.fillStyle = '#059669';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Validated Locations Map', canvas.width / 2, 50);
            
            ctx.fillStyle = '#6b7280';
            ctx.font = '18px Arial';
            ctx.fillText(`${locationsData.length} Validated Locations | Generated: ${new Date().toLocaleDateString()}`, canvas.width / 2, 80);
            
            // FIXED: Centered coordinate plot
            const bounds = getLocationBounds();
            const plotArea = { 
                x: (canvas.width - 1000) / 2, 
                y: 120, 
                width: 1000, 
                height: 600 
            };
            
            // Background
            ctx.fillStyle = '#e0f2fe';
            ctx.fillRect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
            ctx.strokeStyle = '#0369a1';
            ctx.lineWidth = 2;
            ctx.strokeRect(plotArea.x, plotArea.y, plotArea.width, plotArea.height);
            
            // Plot points without labels
            locationsData.forEach((location) => {
                const x = plotArea.x + ((location.lng - bounds.west) / (bounds.east - bounds.west)) * plotArea.width;
                const y = plotArea.y + ((bounds.north - location.lat) / (bounds.north - bounds.south)) * plotArea.height;
                
                ctx.fillStyle = locationColors[location.name];
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // NO LABELS
            });
            
            // Add legend below plot
            const legendY = plotArea.y + plotArea.height + 50;
            addLegendToCanvas(ctx, 50, legendY, canvas.width - 100, 120);
            
            const link = document.createElement('a');
            link.download = `validated-locations-map-${new Date().toISOString().split('T')[0]}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            document.getElementById('downloadProgress').classList.add('hidden');
            showMessage('‚úÖ Fallback PNG downloaded with proper layout!', 'success');
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function updateMapInfo() {
            const zoom = map.getZoom().toFixed(1);
            const center = map.getCenter();
            
            document.getElementById('currentZoom').textContent = zoom;
            document.getElementById('currentCenter').textContent = `${center.lat.toFixed(2)}, ${center.lng.toFixed(2)}`;
        }

        // Initialize map
        map.on('load', function() {
            assignLocationColors();
            createLocationLegend();
            addMarkersToMap();
            updateMapInfo();
        });

        map.on('zoom', updateMapInfo);
        map.on('move', updateMapInfo);

        function showMessage(message, type) {
            const container = document.getElementById('messageContainer');
            const colors = {
                'success': 'bg-green-100 text-green-800 border-green-300',
                'error': 'bg-red-100 text-red-800 border-red-300',
                'info': 'bg-blue-100 text-blue-800 border-blue-300'
            };
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `${colors[type]} border-2 px-6 py-4 rounded-xl shadow-lg backdrop-blur-sm max-w-md`;
            messageDiv.innerHTML = `
                <div class="flex items-center text-sm font-medium">
                    <span>${message}</span>
                </div>
            `;
            
            messageDiv.style.opacity = '0';
            messageDiv.style.transform = 'translateY(-20px)';
            container.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.opacity = '1';
                messageDiv.style.transform = 'translateY(0)';
                messageDiv.style.transition = 'all 0.3s ease';
            }, 10);
            
            setTimeout(() => {
                messageDiv.style.opacity = '0';
                messageDiv.style.transform = 'translateY(-20px)';
                setTimeout(() => messageDiv.remove(), 300);
            }, 5000);
        }

        setTimeout(() => {
            if (locationsData.length > 0) {
                showMessage(`üó∫Ô∏èAll Validated coordinates.`, 'info');
            }
        }, 1000);
    </script>
</body>
</html>